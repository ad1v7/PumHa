*****
PumHa
*****
PumHa package simulates the population dynamics of hares and pumas in a user-specified landscape. The population densities depend on a number of parameters, such as birth, death and diffucion rates, also on a rate at which pumas eat hares. For more in-depth mathematical formulation, see PumaPopulation and HarePopulation classes in the pumha.pop module.

PumHa is written in Python programming language, it is compatible with any version of Python 2.7 or higher. Provided the package is correctly installed (see `How to install`_), it can be run in variety of operating systems (see `System compatibility and requirements`_ for a list of operating systems in which the package has been tested). 

The package was developed using `GitHub`_ revision control mechanism and the tests were created using Python's `unittest`_ framework. The code complies with `PEP 257`_ and `PEP 8`_ conventions.

.. _PEP 257: https://www.python.org/dev/peps/pep-0257/ 
.. _PEP 8: https://www.python.org/dev/peps/pep-0008/
.. _GitHub: https://github.com/
.. _unittest: https://docs.python.org/2/library/unittest.html
.. _nose: https://pypi.python.org/pypi/nose/1.3.7



How to install
==============
To install PumHa package on a Linux machine (see `System compatibility and requirements`_ for known compatibility):

1. Change directory to your install directory (or create one).
2. Copy repository from Github by running the command
::

    git clone https://github.com/ad1v7/PumHa


Alternatively, if you are lucky to have a tar.gz package in your computer (in fact you would be very lucky because only 4 people out of 7+ billions have it!), you can do the following:
1. Extract archive content using
::
    
     tar zxvf pumha.tar.gz
        
        
where pumha.tar.gz is replaced with your archive name


2. Make sure you are in a directory which contains setup.py
and use `pip <http://pip-installer.org>`_::

    pip install .
    
You might need to run above command as super user (root)::

    sudo pip install .
    
If you can't run it as a root, you can try
::

    pip install --user .
    
In a that case pip will install command line script into
::

    ~/.local/bin
    
directory. This is the case for Scientific Linux and Ubuntu.

::

If ``~/.local/bin`` is not in your ``$PATH`` (run ``echo $PATH`` to check it),
you can export it running 
::

    export PATH=$PATH:~/.local/bin
    
You may want to add above line to ``~/.profile`` so ``~/.local/bin`` is added to the path at login.


How to use
==========

Once you have correctly installed the package, you can run the simulation from any directory by typing into the command line
::
    pumha <landscape_file> [<config_file>]


``<config_file>`` is a JSON type configuration file that contains all the information about the parameter values. You are welcome to play around with those values! You can find the default configuration file ``default.dat`` from  ``...installation_path/pumha/data`` directory (you can copy-paste it into your simulation directory, if you want). Note that you need to specify an absolute path to the input files in case they are not in the directory in which you run the simulation.

If configuration file is not provided, the program will display warning and will continue using the default values form ``default.dat`` file. If configuration file is not present or was accidentally deleted, it can be regenerated by running a simulation without specifying config file::
   
        pumha <landscape_file>

Therefore the simulation can be run without specifying a configuration file, but you must provide a ``<landscape_file>``. This file must be a bitmask ASCII file with the first row giving the dimensions of the landscape and rest of the rows representing landscape (1 for land square and 0 for water), as an example,
::
  5 5

  1 1 1 1 1 
  1 1 1 1 0  
  1 0 0 0 0  
  1 1 0 0 0  
  1 1 0 0 0

There are some example landscapes in the ``...installation_path/pumha/data`` directory.


Once you have run the simulation, an output folder with a time stamp ``PumHa_out_Y-m-d-H-M-S`` will be created in your simulation directory. In that directory there will be a file ``average_densities.dat`` in which there are three columns, the first column giving a timestep value and rest two showing the average values of hare and puma densities on the whole landscape respectively. The average values are calculated for the whole landscape, including the water squares.

Rest of the files in the output folder are image files that describe the densities of pumas and hares on a given timestep. Each pixel represents a square on landscape grid. Blue pixels denote water. On the pixels representing land, red denotes puma density and yellow hare density (so the more red/yellow the square, the higher is puma/hare population on that square). The population values are scaled to an interval between 0 and 225, 225 representing the highest density of animals that appeared in the whole simulation on a single square.  

Options:

``-h --help``    Show this screen and exit
    
``--version``    Print current version



How to  run tests
=================

To run the tests, go into the directory which contains ``setup.py`` and run the following command::

    python setup.py test

Depending on how you have installed the package, you might need to run the tests as root::

    sudo python setup.py test
  
Testing requires nose_ which will be installed by pip_ automatically together with other dependencies.


System compatibility and requirements
=====================================

The package was tested on::

    Scientific Linux release 7.3 (Nitrogen)
    Ubuntu 16.04.3 LTS
    Ubuntu 14.04 LTS
    Windows 10 Home
    
The package is likely to work on other systems as well, but there is no guarantee to that. Also, if you are using an operating system which is not listed above, the installation procedure may also differ from the one outlined in this document.

.. _numpy: https://pypi.python.org/pypi/numpy
.. _simplejson: https://pypi.python.org/pypi/simplejson/
.. _scipy: https://pypi.python.org/pypi/scipy
.. _tqdm: https://pypi.python.org/pypi/tqdm
.. _jsonschema: https://pypi.python.org/pypi/jsonschema
.. _docopt: https://pypi.python.org/pypi/docopt

The package requires following dependencies:

* `numpy`_ >=1.9.2
* `simplejson`_>=3.8.1
* `scipy`_>=0.15.1
* `tqdm`_>=4.19.4
* `jsonschema`_>=2.6.0
* `docopt`_>=0.6.2

The package has been tested with the minimum required version, but it is likely that the package will work with older versions as well. 

Above packages should be installed automatically when using pip_ (as described in the section `How to install`_). However, if there are some issues with the installation, they can be installed separately using pip_::
    
    sudo pip install  package_name
    
or if root is not available::

    pip install --user package_name
    
    
Key design decisions
====================

This section discusses some design and implementation decisions.

Usage properties
----------------

PumHa package has been designed keeping the ease of usage in mind. All the additional packages required for the code to run can easily installed with `pip`_ (see `How to install`_). Since it can be installed as a Python module, it can be easily used as a part of other simulation softwares.

[sth about how nice it is to have all your simulations in separate output folders]

[what else?]

Handling input
--------------

The package has nice buit-in mechanisms for handling invalid input data:

* If a configuration file is not in a JSON format or has invalid input values, the program terminates the simulation and generates a new configuration file in a correct format, giving the user an opportunity to "try again" by parameter values in a corrrect configuration file.

* If the user does not have configuration file or has deleted the default one, it is simple to generate a new one - simply run the program without specifying a configuration file!

* The program will display an error message and terminate if no landscape file is provided or if the landscape file is not in a correct format, since there is no point in running a simulation on a landscape that is not the one user wanted to simulate.

[Is all this correct? What else should be mentioned?]

Class structure
---------------

[fancy words to use from lecture slides: cohesion, loose coupling, modular programming]

[how easy/difficult is it to use modules separately, e.g. as a part of another program?]

[no output for more and less than 2 populations]

[why we opted for using inheritance]

[what else?]

Output and visualisation
------------------------

The output file that lists average densities at given timesteps has the timestep value, hare density and puma density written as three columns, making it simple to plot. 

There were several difficult decisions to make regarding to the visualisation of the densities on the landscape. In this program, both puma and hare densities on a given time step are shown on one map, one pixel corresponding to one square on a grid, blue representing water, yellow hare density and red puma density (for more information about the output, see `How to use`_). One of the biggest issues with visualizing population value changes over time is the scaling of the colour values. In order to scale the colours such that the highest colour value represents the highest population density encountered in the simulation, one would need to wait until the simulation is done and then rewrite all the files with correct scaling. Thankfully, there is a nice feature in the PPM file format - a scaling factor, which scales all the values in the file according to that factor. Going over all the PPM output files once the simulation is done and scaling every value separately would make the simulation ridiculously long, however, changing one value in every input file is less of a problem. 

This kind of output functionality is only implemented for the case where there are exactly two populations. There is also a method that checks that and returns an error message if that is not the case.

[what else?]

* Why this class structure and relations
* Explain scalability
* easy to create new populations by extending Population class
* can be imported as a python module to simply create tailor-made simulations
* main scalability constrain is requirement to write new ppm output method
  when number of populations in a simulation is different than 2
* I'm not really sure what to put here. Who's up for a challenge to write it down?


ToDo
########
Make sure that below tasks are distributed evenly

* Check is density array type of double precision float (float64)

  - answer: is not -> change to float64
* Add unit tests

  - how can we verify that the simulation does what it supposed to do?
* Add comments if necessary

  - comment other people code: this is the best way to improve!
  - ask if something is unclear -> this could be a bug
* add docstring to each module (top of each .py file)
* Add docstrings to each class and every public method

  - build documentation with Sphinx and add to docs directory
  - ...but wait for:
* Check code compliance with pep8 and pep257

  - Do it but after all unittests and docstrings are added
* Prepare Readme file

  - discuss content
  - find a volunteer :-)
* what data we want to include with the package
* Check, verify and discuss output
* Discuss module structure
* Go over requirements and make sure all tasks are either assigned or completed
* time step attribute in Population looks rather awkward; add it to Simulation?
* make sure output is saved every T step
* decide format of ppm file, how to get round 70 characters per line limit?

Puma Package
########
* should simulation continue after default config is created?
* clarify input and output
* what data include with the package
* add print frequency to the config
* scaling for ppm files
* probably need to have variable to store absolute path to output directory


* Information on the programming language, revision control, debuggers, build tools, and test tools you
have used.

* Where to get, and how to build and install, any third-party packages needed by your code (for
packages that are not already on the Physics Computational Lab machines).
* How to build your code.

* How to run your code.

* How to run your tests.

* Summary of key design decisions and reasons for these.

