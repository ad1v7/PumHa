%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}


\title{PumHa Documentation}
\date{Nov 02, 2017}
\release{1.0.0}
\author{Chloe Sumner, Elen Kalda, Marcin Kirsz}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


PumHa package simulates the population dynamics of hares and pumas in a user-specified landscape. The population densities depend on a number of parameters, such as birth, death and diffusion rates, also on a rate at which pumas eat hares. For more in-depth mathematical formulation, see PumaPopulation and HarePopulation classes in the pumha.pop module.

PumHa is written in Python programming language, it is compatible with any version of Python 2.7 or higher. Provided the package is correctly installed (see {\hyperref[\detokenize{index:how-to-install}]{\sphinxcrossref{How to install}}}), it can be run in variety of operating systems (see {\hyperref[\detokenize{index:system-compatibility-and-requirements}]{\sphinxcrossref{System compatibility and requirements}}} for a list of operating systems in which the package has been tested).

The package was developed using \sphinxhref{https://github.com/}{GitHub} revision control mechanism and the tests were created using Python’s \sphinxhref{https://docs.python.org/2/library/unittest.html}{unittest} framework. The code complies with \sphinxhref{https://www.python.org/dev/peps/pep-0257/}{PEP 257} and \sphinxhref{https://www.python.org/dev/peps/pep-0008/}{PEP 8} conventions. The documentation was generated using Sphinx and it is located in the \sphinxcode{docs} folder inside the project directory.


\chapter{How to install}
\label{\detokenize{index:welcome-to-pumha-s-documentation}}\label{\detokenize{index:how-to-install}}\label{\detokenize{index:nose}}
To install PumHa package on a Linux machine (see {\hyperref[\detokenize{index:system-compatibility-and-requirements}]{\sphinxcrossref{System compatibility and requirements}}} for known compatibility):
\begin{enumerate}
\item {} 
Change directory to your install directory (or create one).

\item {} 
Copy repository from Github by running the command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{git} \PYG{n}{clone} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{ad1v7}\PYG{o}{/}\PYG{n}{PumHa}
\end{sphinxVerbatim}

\end{enumerate}

Alternatively, if you are lucky to have a tar.gz package in your computer (in fact you would be very lucky because only 4 people out of 7+ billions have it!), you can do the following:
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
Or extract archive content using:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{tar} \PYG{n}{zxvf} \PYG{n}{pumha}\PYG{o}{.}\PYG{n}{tar}\PYG{o}{.}\PYG{n}{gz}
\end{sphinxVerbatim}

\end{enumerate}

where pumha.tar.gz is replaced with your archive name
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
Make sure you are in a directory which contains setup.py and use \sphinxhref{http://pip-installer.org}{pip}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{o}{.}
\end{sphinxVerbatim}

\end{enumerate}

You might need to run above command as super user (root):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{pip} \PYG{n}{install} \PYG{o}{.}
\end{sphinxVerbatim}

If you can’t run it as a root, you can try:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{user} \PYG{o}{.}
\end{sphinxVerbatim}

In that case pip will install command line script into:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZti{}}\PYG{o}{/}\PYG{o}{.}\PYG{n}{local}\PYG{o}{/}\PYG{n+nb}{bin}
\end{sphinxVerbatim}

directory. This is the case for Scientific Linux and Ubuntu.

If \sphinxcode{\textasciitilde{}/.local/bin} is not in your \sphinxcode{\$PATH} (run \sphinxcode{echo \$PATH} to check it), you can export it running:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
export PATH=\PYGZdl{}PATH:\PYGZti{}/.local/bin
\end{sphinxVerbatim}

You may want to add above line to \sphinxcode{\textasciitilde{}/.profile} so \sphinxcode{\textasciitilde{}/.local/bin} is added to the path at login.

If you want to use the package with python 3 you might need to run pip3 in place of pip for above commands.


\chapter{How to use}
\label{\detokenize{index:how-to-use}}
Once you have correctly installed the package, you can run the simulation from any directory by typing into the command line:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pumha} \PYG{o}{\PYGZlt{}}\PYG{n}{landscape\PYGZus{}file}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{o}{\PYGZlt{}}\PYG{n}{config\PYGZus{}file}\PYG{o}{\PYGZgt{}}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxcode{\textless{}config\_file\textgreater{}} is a JSON type configuration file that contains all the information about the parameter values. You are welcome to play around with those values! You can find the default configuration file \sphinxcode{default.dat} in  \sphinxcode{...installation\_path/pumha/data} directory (you can copy-paste it into your simulation directory, if you want).

If configuration file is not provided, the program will display warning and will continue using the default values form \sphinxcode{default.dat} file. If configuration file is not present or was accidentally deleted, it can be regenerated by running a simulation without specifying config file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pumha} \PYG{o}{\PYGZlt{}}\PYG{n}{landscape\PYGZus{}file}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Therefore the simulation can be run without specifying a configuration file, but you must provide a \sphinxcode{\textless{}landscape\_file\textgreater{}}. This file must be a bitmask ASCII file with the first row giving the dimensions of the landscape and rest of the rows representing landscape (1 for land square and 0 for water), as an example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{5} \PYG{l+m+mi}{7}

\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

There are some example landscapes in the \sphinxcode{...installation\_path/pumha/data} directory.

Once you have run the simulation, an output folder with a time stamp \sphinxcode{PumHa\_out\_Y-m-d-H-M-S} will be created in your simulation directory. In that directory there will be a file \sphinxcode{average\_densities.dat} in which there are three columns, the first column giving a timestep value and rest two showing the average values of hare and puma densities on the whole landscape respectively. The average values are calculated for the whole landscape, including the water squares.

Rest of the files in the output folder are ppm image files that describe the densities of pumas and hares on a given timestep. Each pixel represents a square on landscape grid. Blue pixels denote water. On the pixels representing land, red denotes puma density and green hare density (so the more red/green the square, the higher is puma/hare population on that square). The population values are scaled relative to the highest density of animals that appeared in the whole simulation on a single square.


\chapter{How to  run tests}
\label{\detokenize{index:how-to-run-tests}}
To run the tests, go into the directory which contains \sphinxcode{setup.py} and run the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{n}{setup}\PYG{o}{.}\PYG{n}{py} \PYG{n}{test}
\end{sphinxVerbatim}

Depending on how you have installed the package, you might need to run the tests as root:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{python} \PYG{n}{setup}\PYG{o}{.}\PYG{n}{py} \PYG{n}{test}
\end{sphinxVerbatim}

Testing requires \sphinxhref{https://pypi.python.org/pypi/nose/1.3.7}{nose} which will be installed by \sphinxhref{http://pip-installer.org}{pip} automatically together with other dependencies.


\chapter{System compatibility and requirements}
\label{\detokenize{index:system-compatibility-and-requirements}}
The package was tested on:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Scientific} \PYG{n}{Linux} \PYG{n}{release} \PYG{l+m+mf}{7.3} \PYG{p}{(}\PYG{n}{Nitrogen}\PYG{p}{)}
\PYG{n}{Ubuntu} \PYG{l+m+mf}{16.04}\PYG{o}{.}\PYG{l+m+mi}{3} \PYG{n}{LTS}
\PYG{n}{Ubuntu} \PYG{l+m+mf}{14.04} \PYG{n}{LTS}
\PYG{n}{Windows} \PYG{l+m+mi}{10} \PYG{n}{Home}
\end{sphinxVerbatim}

The package is likely to work on other systems as well, but there is no guarantee to that. Also, if you are using an operating system which is not listed above, the installation procedure may also differ from the one outlined in this document.

The package requires following dependencies:
\begin{itemize}
\item {} 
\sphinxhref{https://pypi.python.org/pypi/numpy}{numpy} \textgreater{}=1.9.2

\item {} 
\sphinxhref{https://pypi.python.org/pypi/simplejson/}{simplejson}\textgreater{}=3.8.1

\item {} 
\sphinxhref{https://pypi.python.org/pypi/scipy}{scipy}\textgreater{}=0.15.1

\item {} 
\sphinxhref{https://pypi.python.org/pypi/tqdm}{tqdm}\textgreater{}=4.19.4

\item {} 
\sphinxhref{https://pypi.python.org/pypi/jsonschema}{jsonschema}\textgreater{}=2.6.0

\item {} 
\sphinxhref{https://pypi.python.org/pypi/docopt}{docopt}\textgreater{}=0.6.2

\end{itemize}

The package has been tested with the minimum required version, but it is likely that the package will work with older versions as well.

Above packages should be installed automatically when using \sphinxhref{http://pip-installer.org}{pip} (as described in the section {\hyperref[\detokenize{index:how-to-install}]{\sphinxcrossref{How to install}}}). However, if there are some issues with the installation, they can be installed separately using \sphinxhref{http://pip-installer.org}{pip}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{pip} \PYG{n}{install}  \PYG{n}{package\PYGZus{}name}
\end{sphinxVerbatim}

or if root is not available:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{user} \PYG{n}{package\PYGZus{}name}
\end{sphinxVerbatim}


\chapter{Key design decisions}
\label{\detokenize{index:key-design-decisions}}
This section discusses some design and implementation decisions.


\section{Usage properties}
\label{\detokenize{index:usage-properties}}
PumHa package has been designed keeping the ease of usage in mind. All the additional packages required for the code to run can easily installed with \sphinxhref{http://pip-installer.org}{pip} (see {\hyperref[\detokenize{index:how-to-install}]{\sphinxcrossref{How to install}}}). Since it can be installed as a Python module, it can be easily used as a part of other simulation softwares.

Every simulation produces an output folder with a timestamp in its name, making it easy to keep track of previously run simulations.


\section{Handling input}
\label{\detokenize{index:handling-input}}
The package has nice buit-in mechanisms for handling invalid input data:
\begin{itemize}
\item {} 
If a configuration file is not in a JSON format or has invalid input values, the program terminates the simulation and generates a new configuration file in a correct format, giving the user an opportunity to “try again” by changing parameter values in a correct configuration file.

\item {} 
Classes Landscape and Configuration that deal with user input, have built-in error checks, that can handle majority of cases.

\item {} 
If the user does not have configuration file or has deleted the default one, it is simple to generate a new one - simply run the program without specifying a configuration file!

\item {} 
The program will display an error message and terminates if no landscape file is provided or if the landscape file is not in a correct format, since there is no point in running a simulation on a landscape that is not the one user wanted to simulate.

\end{itemize}


\section{Class structure}
\label{\detokenize{index:class-structure}}
The code is modular and loosely coupled and it is hence easy to extend it and make changes locally, without having to rewrite methods in different modules or classes. With the choice of variable names, the code aims to be as self-documenting as possible.

The modular structure and use of inheritance in the pumha.pop module allows modules and classes to be used in different projects. The population class has methods relevant to all populations, a user can create their own subclass with corresponding methods (that perhaps use different mathematical formalism). Setting up a simulation is very simple, requiring only at the least a landscape file and one population to be specified. Hence it is simple to create custom tailored simulations.

Though it is possible to extend the code to include several populations, the output functions are specific to the case of two populations. There is a function that checks the number of populations in the simulation and if it is other than two, it displays a message and continues the simulation without providing output.

To make the simulation faster, the methods responsible for the density updates only loop over land squares. For standard landscapes this implementation can reduce the total simulation time around four times.


\section{Output and visualisation}
\label{\detokenize{index:output-and-visualisation}}
The output file that lists average densities at given timesteps has the timestep value, hare density and puma density written as three columns respectively, making it simple to plot.

In out visualisation implementation, both puma and hare densities on a given time step are shown on one PPM file, one pixel corresponding to one square on a grid, blue without any red or green representing water, green hare density and red puma density (for more information about the output, see {\hyperref[\detokenize{index:how-to-use}]{\sphinxcrossref{How to use}}}). The RGB values representing the puma and hare densities are equal to the actual value of the density at the square. The colours are scaled using the maximum value of the density found during the simulation.

Since a line in a plain PPM file must be no longer than 70 characters, all the RGB values are written into an array of strings, each element in an array corresponging to a pixel. Those strings are then written on a file, four pixels per line (since that is the maximum amount of pixels that could fit to one line if both puma and hare densities are 5-digit numbers).


\chapter{pumha}
\label{\detokenize{index:pumha}}

\section{pumha package}
\label{\detokenize{pumha:pumha-package}}\label{\detokenize{pumha::doc}}

\subsection{pumha.env module}
\label{\detokenize{pumha:pumha-env-module}}\label{\detokenize{pumha:module-pumha.env}}\index{pumha.env (module)}
Environment module.

The module contains one class:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Landscape}
\end{sphinxVerbatim}

The module creates a Landscape object which holds all the landscape-related
information, such as the actual landscape grid array, information about
the number of neighbouring dry squares to each square and indices of land
squares.
\index{Landscape (class in pumha.env)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.env.Landscape}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{pumha.env.}\sphinxbfcode{Landscape}}{\emph{filename}}{}
Bases: \sphinxcode{object}

Class for instantiating a simulation landscape.

Class checks that a valid landscape file exists, then loads it into a
numpy array. The array will be padded with zeros around the
given landscape. The number of land squares (represented by 1) around
every square is then calculated for each array element and this
information is saved into a new numpy array, so this can be used in future
calculations.
Finally, a list of indices is provided for land elements. When updating
the population densities, this list of indices is used to avoid having to
loop over water squares.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
\sphinxstyleliteralstrong{filename} (\sphinxstyleliteralemphasis{string}) \textendash{} name of file holding the landscape array

\end{description}\end{quote}
\index{find\_dry\_squares() (pumha.env.Landscape method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.env.Landscape.find_dry_squares}}\pysiglinewithargsret{\sphinxbfcode{find\_dry\_squares}}{}{}
Count the number of dry squares around each array element.

Assigns to every element of an array a value equal to the sum of it’s
neighbours multiplied by the kernel (see example). Since land squares
have value 1 and water squares have value 0,  multiplying cardinal
neighbours by one and summing gives the total land in the cardinal
directions.

Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Land}\PYG{p}{:}   \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0}    \PYG{n}{Kernel}\PYG{p}{:}    \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0}
        \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}               \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
        \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}               \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

For entry (1,1), the kernel will multiply elements
(0,1), (1,0), (1,2), (2,1) by 1 (from the kernel)
and everything else by 0.
In the land this corresponds to:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{0} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{0} \PYG{o}{=} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

We calculate this value just once and store it to reduce computation.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
array of summed neighbours

\item[{Return type}] \leavevmode
integer array

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_land\_squares\_indices() (pumha.env.Landscape method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.env.Landscape.find_land_squares_indices}}\pysiglinewithargsret{\sphinxbfcode{find\_land\_squares\_indices}}{}{}
Return tuples of all non-zero elements of landscape.

Find the non-zero elements of the landscape array and then
transpose them in to an array of tuples.  This allows for just
iterating over the land elements in later calculations,
significantly reducing the computation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{filename} (\sphinxstyleliteralemphasis{string}) \textendash{} name of file containing land array

\item[{Returns}] \leavevmode
list of indices for zon-zero (land) landscape array elements

\item[{Return type}] \leavevmode
{[}int, int{]} list

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_landscape() (pumha.env.Landscape method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.env.Landscape.load_landscape}}\pysiglinewithargsret{\sphinxbfcode{load\_landscape}}{\emph{filename}}{}
Load the landscape as a numpy array from a file.

Loads an array of 1-s for land and 0-s for water in to a numpy
array from the parsed filename. The array should start on the
second line of the file (the first line contains the size, so it is
skipped in the loading). The method pads the array with a border of
0-s, so that the land is always surrounded by water.
Before loading the landscape, the mehtod checks that the file can be
loaded as a numpy array and then ensures that all entries are either 1
or 0. If either of these checks fails, the simulation will terminate.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{filename} (\sphinxstyleliteralemphasis{string}) \textendash{} name of file containing land array

\item[{Returns}] \leavevmode
padded landscape array

\item[{Return type}] \leavevmode
integer array

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{pumha.main module}
\label{\detokenize{pumha:module-pumha.main}}\label{\detokenize{pumha:pumha-main-module}}\index{pumha.main (module)}
Pumas and hares simulation.
\begin{description}
\item[{Usage: pumha \textless{}landscape\_file\textgreater{} {[}\textless{}config\_file\textgreater{}{]}}] \leavevmode
pumha (-h \textbar{} \textendash{}help \textbar{} \textendash{}version)

\end{description}

The program requires landscape file in the following format:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{3}

\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

The first line in the input file specifies size of the landscape grid.
Land is represented by 1 and water by 0. The program can simulate arbitrary
size grids subject to hardware restrictions.

If config file is not provided, the program will display warning
and will continue using default values.

Arguments:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{landscape\PYGZus{}file}  \PYG{n}{required} \PYG{n}{argument}
\PYG{n}{config\PYGZus{}file}     \PYG{n}{optional} \PYG{n}{config} \PYG{n}{file}
\end{sphinxVerbatim}

Options:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}}\PYG{n}{h} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{help}    \PYG{n}{Show} \PYG{n}{this} \PYG{n}{screen} \PYG{o+ow}{and} \PYG{n}{exit}\PYG{o}{.}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{version}    \PYG{n}{Print} \PYG{n}{current} \PYG{n}{version}
\end{sphinxVerbatim}
\index{main() (in module pumha.main)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.main.main}}\pysiglinewithargsret{\sphinxcode{pumha.main.}\sphinxbfcode{main}}{}{}
Entry point function for the PumHa program.

The function parses user input from the terminal and then sets up,
configures and runs simulation using values in the config file.

\end{fulllineitems}



\subsection{pumha.pop module}
\label{\detokenize{pumha:pumha-pop-module}}\label{\detokenize{pumha:module-pumha.pop}}\index{pumha.pop (module)}
Population module.

The module contains two classes:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Configuration}
\PYG{n}{Population}
\end{sphinxVerbatim}

and two subclasses of the Population class:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{HarePopulation}\PYG{p}{(}\PYG{n}{Population}\PYG{p}{)}
\PYG{n}{PumaPopulation}\PYG{p}{(}\PYG{n}{Population}\PYG{p}{)}
\end{sphinxVerbatim}

The Configuration class consists of several methods for handling and parsing
the input files and Population class with its subclasses are responsible
for doing all the maths in the density change dynamics.
\index{Configuration (class in pumha.pop)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.pop.Configuration}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{pumha.pop.}\sphinxbfcode{Configuration}}{\emph{config\_file}}{}
Bases: \sphinxcode{object}

Class for loading simulation parameters.

Class checks that a valid configuration file has been parsed as an
argument and if not, creates a default one. If a config file is given by
the user, it is checks if it contains a valid JSON object for the
simulation, then loads it as the configuration data and does few more data
validation checks.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode
\sphinxstyleliteralstrong{filename} (\sphinxstyleliteralemphasis{string}) \textendash{} name of file holding the configuration JSON

\end{description}\end{quote}
\index{create\_config() (pumha.pop.Configuration method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.pop.Configuration.create_config}}\pysiglinewithargsret{\sphinxbfcode{create\_config}}{\emph{config\_file}}{}
Create a default configuration file with some standard values.

This method is primarily used as a default when no file
is parsed to a simulation, but is also called when a config
file is passed with an error, so users will have a working
file which they can edit with their own settings.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{config\_file} (\sphinxstyleliteralemphasis{String}) \textendash{} Name of file containing coniguration

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_from\_file() (pumha.pop.Configuration method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.pop.Configuration.load_from_file}}\pysiglinewithargsret{\sphinxbfcode{load\_from\_file}}{\emph{config\_file}}{}
Load json config file.

Load the configuration file as a JSON object and check
that the loaded object has all the correct keys.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{config\_file} (\sphinxstyleliteralemphasis{String}) \textendash{} Name of file containing coniguration

\end{description}\end{quote}

\end{fulllineitems}

\index{valid\_config() (pumha.pop.Configuration method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.pop.Configuration.valid_config}}\pysiglinewithargsret{\sphinxbfcode{valid\_config}}{\emph{config\_file}}{}
Validate format of configuration file.

Checks that the configuration file is a JSON file in
the correct format by comparing it to an expected schema.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{config\_file} (\sphinxstyleliteralemphasis{String}) \textendash{} Name of file containing coniguration

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{HarePopulation (class in pumha.pop)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.pop.HarePopulation}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{pumha.pop.}\sphinxbfcode{HarePopulation}}{\emph{Landscape}, \emph{birth=0.08}, \emph{death=0.04}, \emph{diffusion=0.2}, \emph{min\_ro=0.0}, \emph{max\_ro=5.0}, \emph{dt=0.4}}{}
Bases: {\hyperref[\detokenize{pumha:pumha.pop.Population}]{\sphinxcrossref{\sphinxcode{pumha.pop.Population}}}}

Hare population class with its specific update method.

This class represents hare population living in some landscape, therefore
it requires Landscape object as a parameter. Remaining parameters are set
to defaults and can be changed later either using provided method
load\_config or by simply assigning required values to instance attributes.
For example use see PumaPopulation.

\sphinxstyleemphasis{See Also}
\begin{itemize}
\item {} 
pumha.pop.Population

\item {} 
pumha.pop.PumaPopulation

\end{itemize}
\index{update\_density() (pumha.pop.HarePopulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.pop.HarePopulation.update_density}}\pysiglinewithargsret{\sphinxbfcode{update\_density}}{\emph{populations\_old}, \emph{populations\_new}}{}
Update density array of hare population instance.

Method updates entire density array of hare population instance based
on densities of current populations living in a landscape. Only land
squares in the density array are updated.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{populations\_old} (\sphinxstyleliteralemphasis{list of Population type}) \textendash{} list of populations at current timestep

\item {} 
\sphinxstyleliteralstrong{populations\_new} (\sphinxstyleliteralemphasis{list of Extended Population type}) \textendash{} list of populations with updated density array at t+dt

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_density\_ij() (pumha.pop.HarePopulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.pop.HarePopulation.update_density_ij}}\pysiglinewithargsret{\sphinxbfcode{update\_density\_ij}}{\emph{i}, \emph{j}, \emph{P}, \emph{H}}{}
Return updated hare density at one (ij) square.

Method implements discrete approximation of the following equation:
\begin{equation*}
\begin{split}\frac{\partial H}{\partial t} = rH-aHP+k(\frac{\partial^2 H}             {\partial x^2} + \frac{\partial^2 H}{\partial y^2})\end{split}
\end{equation*}
where
\begin{itemize}
\item {} 
P = density of pumas

\item {} 
H = density of hares

\item {} 
r = birth rate of hares

\item {} 
a = death rate of hares

\item {} 
k = diffusion rate of hares

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{i} (\sphinxstyleliteralemphasis{int}) \textendash{} density array row number (first row is i=0)

\item {} 
\sphinxstyleliteralstrong{j} (\sphinxstyleliteralemphasis{int}) \textendash{} density array column number (first column is j=0)

\item {} 
\sphinxstyleliteralstrong{P} (\sphinxstyleliteralemphasis{numpy.ndarray of float type}) \textendash{} density array of pumas

\item {} 
\sphinxstyleliteralstrong{H} (\sphinxstyleliteralemphasis{numpy.ndarray of float type}) \textendash{} density array of hares

\end{itemize}

\item[{Returns}] \leavevmode
updated density ij square

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Population (class in pumha.pop)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.pop.Population}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{pumha.pop.}\sphinxbfcode{Population}}{\emph{landscape\_inp}, \emph{birth}, \emph{death}, \emph{diffusion}, \emph{min\_ro}, \emph{max\_ro}, \emph{dt}}{}
Bases: \sphinxcode{object}

Base class for creating specific population classes.

Class stores instance attributes and provides methods which can be used by
for derived subclasses. It is not intended to be used on its own, but
should be extended by specific population subclasses (e.g. PumaPopulation)
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{min\_ro} (\sphinxstyleliteralemphasis{float}) \textendash{} minimum density per ij square in the density array

\item {} 
\sphinxstyleliteralstrong{max\_ro} (\sphinxstyleliteralemphasis{float}) \textendash{} maximum density per ij square in the density array

\item {} 
\sphinxstyleliteralstrong{birth} (\sphinxstyleliteralemphasis{float}) \textendash{} birth rate for a given population

\item {} 
\sphinxstyleliteralstrong{death} (\sphinxstyleliteralemphasis{float}) \textendash{} death rate for a given population

\item {} 
\sphinxstyleliteralstrong{diffusion} (\sphinxstyleliteralemphasis{float}) \textendash{} diffusion rate for a given population

\item {} 
\sphinxstyleliteralstrong{dt} (\sphinxstyleliteralemphasis{float}) \textendash{} time step in arbitrary units

\item {} 
\sphinxstyleliteralstrong{density} (\sphinxstyleliteralemphasis{numpy.ndarray containing data with float type}) \textendash{} population density in a given landscape initialized at random

\end{itemize}

\end{description}\end{quote}
\index{find\_density\_arr() (pumha.pop.Population method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.pop.Population.find_density_arr}}\pysiglinewithargsret{\sphinxbfcode{find\_density\_arr}}{\emph{pop\_class}, \emph{pop\_list}}{}
Get required population density array from a list of populations.

Returns density array of a first found element matching pop\_class from
a list of provided populations. If no element is found, it returns
matrix of zeros.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{pop\_class} (\sphinxstyleliteralemphasis{extended Population class}) \textendash{} required population object

\item {} 
\sphinxstyleliteralstrong{pop\_list} (\sphinxstyleliteralemphasis{list}) \textendash{} list of all populations

\end{itemize}

\item[{Returns}] \leavevmode
required population density array(array of zeros if not found)

\item[{Return type}] \leavevmode
numpy.ndarray of float type

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_config() (pumha.pop.Population method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.pop.Population.load_config}}\pysiglinewithargsret{\sphinxbfcode{load\_config}}{\emph{birth}, \emph{death}, \emph{diffusion}, \emph{dt}}{}
Set instance attributes using provided parameters.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{birth} (\sphinxstyleliteralemphasis{float}) \textendash{} birth rate of a given population

\item {} 
\sphinxstyleliteralstrong{death} (\sphinxstyleliteralemphasis{float}) \textendash{} death rate of a given population

\item {} 
\sphinxstyleliteralstrong{diffusion} (\sphinxstyleliteralemphasis{float}) \textendash{} diffusion rate of a given population

\item {} 
\sphinxstyleliteralstrong{dt} (\sphinxstyleliteralemphasis{float}) \textendash{} timestep in arbitrary units

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{random\_density() (pumha.pop.Population method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.pop.Population.random_density}}\pysiglinewithargsret{\sphinxbfcode{random\_density}}{\emph{landscape\_inp}}{}
Assign a random density between min and max ro to every land square.

Returns a grid with a random density assigned
between minimum and maximum densities for every land square.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{landscape\_inp} ({\hyperref[\detokenize{pumha:pumha.env.Landscape}]{\sphinxcrossref{\sphinxstyleliteralemphasis{Landscape}}}}) \textendash{} Instance of a Landscape object

\item[{Returns}] \leavevmode
a 2D array of random densities

\item[{Return type}] \leavevmode
numpy.ndarray of float type

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{PumaPopulation (class in pumha.pop)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.pop.PumaPopulation}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{pumha.pop.}\sphinxbfcode{PumaPopulation}}{\emph{Landscape}, \emph{birth=0.02}, \emph{death=0.06}, \emph{diffusion=0.2}, \emph{min\_ro=0.0}, \emph{max\_ro=5.0}, \emph{dt=0.4}}{}
Bases: {\hyperref[\detokenize{pumha:pumha.pop.Population}]{\sphinxcrossref{\sphinxcode{pumha.pop.Population}}}}

Puma population class with its specific update method.

This class represents puma population living in some landscape,
therefore it requires Landscape object as a parameter.
Remaining parameters are set to defaults and can be changed later
by either using provided method load\_config or by simply assigning
required values to instance attributes.
\begin{quote}\begin{description}
\item[{Example}] \leavevmode
Create puma population using default values

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{pumha}\PYG{n+nn}{.}\PYG{n+nn}{pop} \PYG{k}{import} \PYG{n}{PumaPopulation}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{pumha}\PYG{n+nn}{.}\PYG{n+nn}{env} \PYG{k}{import} \PYG{n}{Landscape}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{land} \PYG{o}{=} \PYG{n}{Landscape}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{my\PYGZus{}land\PYGZus{}file.dat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{puma} \PYG{o}{=} \PYG{n}{PumaPopulation}\PYG{p}{(}\PYG{n}{land}\PYG{p}{)}
\end{sphinxVerbatim}

Create puma population using specifig values

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{pumha}\PYG{n+nn}{.}\PYG{n+nn}{pop} \PYG{k}{import} \PYG{n}{PumaPopulation}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{pumha}\PYG{n+nn}{.}\PYG{n+nn}{env} \PYG{k}{import} \PYG{n}{Landscape}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{land} \PYG{o}{=} \PYG{n}{Landscape}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{my\PYGZus{}land\PYGZus{}file.dat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{puma} \PYG{o}{=} \PYG{n}{PumaPopulation}\PYG{p}{(}\PYG{n}{land}\PYG{p}{,} \PYG{n}{birth}\PYG{o}{=}\PYG{l+m+mf}{0.03}\PYG{p}{,} \PYG{n}{death}\PYG{o}{=}\PYG{l+m+mf}{0.01}\PYG{p}{)}
\end{sphinxVerbatim}

\item[{See Also}] \leavevmode
\end{description}\end{quote}

pumha.pop.Population
\index{update\_density() (pumha.pop.PumaPopulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.pop.PumaPopulation.update_density}}\pysiglinewithargsret{\sphinxbfcode{update\_density}}{\emph{populations\_old}, \emph{populations\_new}}{}
Update density array of puma population instance.

Method updates entire density array of puma population instance based
on densities of current populations living in a landscape. Only land
squares in the density array are updated.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{populations\_old} (\sphinxstyleliteralemphasis{list of Population type}) \textendash{} list of populations at current timestep

\item {} 
\sphinxstyleliteralstrong{populations\_new} (\sphinxstyleliteralemphasis{list of Population type}) \textendash{} list of populations with updated density array at t+dt

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_density\_ij() (pumha.pop.PumaPopulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.pop.PumaPopulation.update_density_ij}}\pysiglinewithargsret{\sphinxbfcode{update\_density\_ij}}{\emph{i}, \emph{j}, \emph{P}, \emph{H}}{}
Return updated puma density at one (i,j) square.

Method implements discrete approximation of the following equation:
\begin{equation*}
\begin{split}\frac{\partial P}{\partial t} = bHP-mP+l(\frac{\partial^2 P}                     {\partial x^2} + \frac{\partial^2 P}{\partial y^2})\end{split}
\end{equation*}
where
\begin{itemize}
\item {} 
P = density of pumas

\item {} 
H = density of hares

\item {} 
b = birth rate of pumas

\item {} 
m = death rate of pumas

\item {} 
l = diffusion rate of pumas

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{i} (\sphinxstyleliteralemphasis{int}) \textendash{} density array row number (first row is i=0)

\item {} 
\sphinxstyleliteralstrong{j} (\sphinxstyleliteralemphasis{int}) \textendash{} density array column number (first column is j=0)

\item {} 
\sphinxstyleliteralstrong{P} (\sphinxstyleliteralemphasis{numpy.ndarray of a float type}) \textendash{} density array of pumas

\item {} 
\sphinxstyleliteralstrong{H} (\sphinxstyleliteralemphasis{numpy.ndarray of a float type}) \textendash{} density array of hares

\end{itemize}

\item[{Returns}] \leavevmode
updated density i, j square

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{pumha.sim module}
\label{\detokenize{pumha:pumha-sim-module}}\label{\detokenize{pumha:module-pumha.sim}}\index{pumha.sim (module)}
Simulation module

Module contains only one class:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Simulation}
\end{sphinxVerbatim}

and one function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{create\PYGZus{}output\PYGZus{}dir}
\end{sphinxVerbatim}

The module is used to build new simulations using
extended Population classes and create the output data.

To run a simulation, use run() method.
\index{Simulation (class in pumha.sim)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.sim.Simulation}}\pysiglinewithargsret{\sphinxbfcode{class }\sphinxcode{pumha.sim.}\sphinxbfcode{Simulation}}{\emph{*args}}{}
Bases: \sphinxcode{object}

Simulate time and space evolution of populations

Only populations added to a populations list are simulated. If no
populations are added, the simulation will run using density arrays of
zeroes. If only one population is added but its update method requires
existence of another population, the simulation will still run using zero
density array for missing population.

This can be interpreted as follows:

Lets add only hare population; its update method requires puma population,
if there are no pumas, since hare death rate is 0, they only increase in
numbers until they rule a land!

Similarly, if there is no hares, pumas will all starve to death.
\begin{quote}\begin{description}
\item[{Example}] \leavevmode
Create new simulation with two populations: puma, hare

Each population is of extended puma.pop.Population type

Run a population over 500 steps and save ppm output every 4th step

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{pumha}\PYG{n+nn}{.}\PYG{n+nn}{sim} \PYG{k}{import} \PYG{n}{Simulation}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sim} \PYG{o}{=} \PYG{n}{Simulation}\PYG{p}{(}\PYG{n}{puma}\PYG{p}{,} \PYG{n}{hare}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sim}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{l+m+mi}{500}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\end{sphinxVerbatim}

\item[{Variables}] \leavevmode
\sphinxstyleliteralstrong{populations} (\sphinxstyleliteralemphasis{list of pumha.pop.Population types}) \textendash{} List of populations in a simulation

\end{description}\end{quote}
\index{add\_population() (pumha.sim.Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.sim.Simulation.add_population}}\pysiglinewithargsret{\sphinxbfcode{add\_population}}{\emph{pop}}{}
Add population object to a simulation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{pop} ({\hyperref[\detokenize{pumha:pumha.pop.Population}]{\sphinxcrossref{\sphinxstyleliteralemphasis{pumha.pop.Population}}}}) \textendash{} a population to be added to a simulation

\end{description}\end{quote}

\end{fulllineitems}

\index{remove\_population() (pumha.sim.Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.sim.Simulation.remove_population}}\pysiglinewithargsret{\sphinxbfcode{remove\_population}}{\emph{pop}}{}
Remove population from a simulation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{pop} ({\hyperref[\detokenize{pumha:pumha.pop.Population}]{\sphinxcrossref{\sphinxstyleliteralemphasis{pumha.pop.Population}}}}) \textendash{} apopulation to be removed from a simulation

\end{description}\end{quote}

\end{fulllineitems}

\index{rescale\_ppm\_files() (pumha.sim.Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.sim.Simulation.rescale_ppm_files}}\pysiglinewithargsret{\sphinxbfcode{rescale\_ppm\_files}}{\emph{max\_density}}{}
Rescale all PPM files using common PPM color value (Maxval)

The method takes the highest recorded density from the entire
simulation and uses it as common scaling factor for all PPM files.
In this way the whole simulation is scaled properly.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{max\_density} (\sphinxstyleliteralemphasis{int}\sphinxstyleliteralemphasis{, }\sphinxstyleliteralemphasis{float}) \textendash{} maximum density for a single square from the run

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (pumha.sim.Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.sim.Simulation.run}}\pysiglinewithargsret{\sphinxbfcode{run}}{\emph{num\_steps}, \emph{save\_freq}}{}
Run a simulation over given number of steps and save an output to PPM

Instance population list is updated every second iteration. At the end
of a simulation it is updated with the latest version.
The method invokes save\_density\_grid\_interface() every save\_freq step
in attempt to save output to a ppm file.
At the end of the simulation rescale\_ppm\_files() method is invoked to
rescale all ppm files using highest value of the density.
Method also includes a simple timer for a loop which prints the
total elapsed time at the end of a simulation to the standard output.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{num\_steps} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of steps for a simulation

\item {} 
\sphinxstyleliteralstrong{save\_freq} (\sphinxstyleliteralemphasis{int}) \textendash{} Number of time steps between outputs

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{save\_average\_density() (pumha.sim.Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.sim.Simulation.save_average_density}}\pysiglinewithargsret{\sphinxbfcode{save\_average\_density}}{\emph{timestep}}{}
Calculate the average density of animals in the whole landscape

The average population is found by summing all the densities in
the grid and dividing it by the numbers of squares in the grid.
The density is saved to a file ‘average\_densities.txt’, where the first
column gives the timestep and second and third columns hare and puma
densities at that time step respectively.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{timestep} (\sphinxstyleliteralemphasis{int}) \textendash{} timestep at which the averages are calculated.

\end{description}\end{quote}

\end{fulllineitems}

\index{save\_density\_grid() (pumha.sim.Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.sim.Simulation.save_density_grid}}\pysiglinewithargsret{\sphinxbfcode{save\_density\_grid}}{\emph{timestep}}{}
Write the densities on each landscape square to a plain PPM file

The method writes the density of a population to a file in the output
folder. The name of a file is in a format timestep.ppm.

The files are in a plain PPM format - each line is separated into
a group of 3 values corresponding to a pixel, each value in those
triplets represents either red, green or blue. The dimension
of the landscape is given in the head of the file. The value after
the dimensions is a scaling factor which is updated in every file
in the end of the simulation, based on the highest maximum density
encountered in the simulation. That is done with the
rescale\_ppm\_files method.

Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{P3}
\PYG{c+c1}{\PYGZsh{} some comment}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{4}
\PYG{l+m+mi}{255}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{255}  \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{255}  \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{255}  \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{255}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{255}  \PYG{l+m+mi}{34} \PYG{l+m+mi}{56} \PYG{l+m+mi}{255}  \PYG{l+m+mi}{28} \PYG{l+m+mi}{60} \PYG{l+m+mi}{255}  \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{255}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{255}  \PYG{l+m+mi}{30} \PYG{l+m+mi}{50} \PYG{l+m+mi}{255}  \PYG{l+m+mi}{30} \PYG{l+m+mi}{57} \PYG{l+m+mi}{225}  \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{255}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{255}  \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{255}  \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{255}  \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{255}
\end{sphinxVerbatim}

This PPM file represents a small island surrounded by water.
Since lines in a PPM file must be no longer than 70 characters,
the function creates an array of strings, every string representing
a pixel and then writes those strings to a file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{timestep} (\sphinxstyleliteralemphasis{int}) \textendash{} the timestep to which the density matrix                 corresponds to

\end{description}\end{quote}

\end{fulllineitems}

\index{save\_density\_grid\_interface() (pumha.sim.Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.sim.Simulation.save_density_grid_interface}}\pysiglinewithargsret{\sphinxbfcode{save\_density\_grid\_interface}}{\emph{i}}{}
Simple interface to save\_density\_grid method

Provides extendable interface to potential group of save\_density\_grid
methods, each one to cover specific case for a simulation. This is
mostly because of the limitation of the PPM file format. Currently only
the case of simulation containing puma and hare populations is
implemented.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{timestep} (\sphinxstyleliteralemphasis{int}) \textendash{} the timestep to which the density                 matrix corresponds to

\end{description}\end{quote}

\end{fulllineitems}

\index{update() (pumha.sim.Simulation method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.sim.Simulation.update}}\pysiglinewithargsret{\sphinxbfcode{update}}{\emph{populations\_old}, \emph{populations\_new}}{}
One step update for all populations in a simulation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{populations\_old} \textendash{} list of populations at time t

\item {} 
\sphinxstyleliteralstrong{populations\_new} \textendash{} list of populations at time t+dt

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{create\_output\_dir() (in module pumha.sim)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pumha:pumha.sim.create_output_dir}}\pysiglinewithargsret{\sphinxcode{pumha.sim.}\sphinxbfcode{create\_output\_dir}}{}{}
Create directory for output PPM and dat files

Directory is created using current date and time. All simulation output
files are saved into this folder. The output directory is created in the
directory where the script is running. The naming convention is as follows:
\begin{quote}

PumHa\_out\_\%Y-\%m-\%d-\%H-\%M-\%S
\end{quote}

\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{p}
\item {\sphinxstyleindexentry{pumha.env}}\sphinxstyleindexpageref{pumha:\detokenize{module-pumha.env}}
\item {\sphinxstyleindexentry{pumha.main}}\sphinxstyleindexpageref{pumha:\detokenize{module-pumha.main}}
\item {\sphinxstyleindexentry{pumha.pop}}\sphinxstyleindexpageref{pumha:\detokenize{module-pumha.pop}}
\item {\sphinxstyleindexentry{pumha.sim}}\sphinxstyleindexpageref{pumha:\detokenize{module-pumha.sim}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}